<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
  <meta charset="UTF-8" />
  <title>Degree Flow</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link rel="stylesheet" href="https://unpkg.com/modern-normalize@2.0.0/modern-normalize.css">

  <style>
    :root{
      --ok:#2e7d32; --ok-bg:#e8f5e9; --ok-b:#10b981;
      --el:#1565c0; --el-bg:#e3f2fd; --el-b:#3b82f6;
      --lo:#9e9e9e; --lo-bg:#f4f4f5; --lo-b:#d0d0d0;
      --ink:#181818; --muted:#636c76;
    }
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,
         "Apple Color Emoji","Segoe UI Emoji";background:#f7f7f8;color:var(--ink)}
    .wrap{max-width:1200px;margin:0 auto;padding:24px 20px}
    header{display:flex;align-items:baseline;justify-content:space-between}
    h1{margin:0 0 6px;font-size:28px}
    .legend{display:flex;gap:18px;margin:4px 0 16px;font-size:14px}
    .legend i{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px;vertical-align:-1px}
    .legend .ok i{background:var(--ok)}
    .legend .el i{background:var(--el)}
    .legend .lo i{background:var(--lo)}
    .top-actions{display:flex;gap:12px}
    #board{position:relative;min-height:520px;background:#fafafa;border:1px solid #eee;border-radius:12px}
    #flow-canvas{position:absolute;inset:0;overflow:visible}
    .node{position:absolute;width:260px;padding:14px 16px;border-radius:12px;border:2px solid transparent;
           box-shadow:0 8px 24px rgba(0,0,0,.06); user-select:none; cursor:grab}
    .node:active{cursor:grabbing}
    .node h3{margin:0 0 8px;font-size:16px}
    .meta{font-size:12px;color:var(--muted)}
    .completed{background:var(--ok-bg);border-color:var(--ok)}
    .eligible{background:var(--el-bg);border-color:var(--el)}
    .locked{background:var(--lo-bg);border-color:var(--lo)}
    .edge{stroke:#b6b6b6;stroke-width:1.5;fill:none}
    .edge.ok{stroke:var(--ok)}
    .edge.eligible{stroke:var(--el)}
    .edge.locked{stroke:#e57373}
    g[tabindex]:focus rect{outline:none;stroke-width:3}
    .hint{color:var(--muted);font-size:12px;margin-top:8px}
    button{padding:8px 12px;border:1px solid #ddd;border-radius:8px;background:white;cursor:pointer}
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>Degree Flow</h1>
      <div class="legend" aria-hidden="true">
        <span class="ok"><i></i>Completed</span>
        <span class="el"><i></i>Eligible</span>
        <span class="lo"><i></i>Locked</span>
      </div>
    </div>
    <div class="top-actions">
      <button id="fit" type="button" aria-label="Fit to screen">Fit</button>
      <a href="/courses">Table view</a>
      <a href="/logout">Logout</a>
    </div>
  </header>

  <div id="board">
    <svg id="flow-canvas" width="1200" height="600" role="img"
         aria-label="Degree requirements flow chart"></svg>
  </div>
  <p class="hint">Tip: drag cards, wheel to zoom (Ctrl/Cmd + +/- also works). Edges update live.</p>
</div>

<!-- Export data as JSON (safe for Thymeleaf) -->
<script th:inline="javascript">
/*<![CDATA[*/
  // Each node from server should have: code, title, credits, core (bool), status ("COMPLETED"|"ELIGIBLE"|"LOCKED"), col (int), row (int)
  // Optional node.unmet: list of missing prereq codes (can be empty)
  const SERVER_NODES = /*[[${nodes}]]*/ [];
  // Each edge from server: requiresCode, courseCode, met (bool)
  const SERVER_EDGES = /*[[${edges}]]*/ [];
/*]]>*/
</script>

<script>
(() => {
  const board = document.getElementById('board');
  const svg   = document.getElementById('flow-canvas');

  // ----- normalize server data -> local DTOs --------------------------------
  const nodes = SERVER_NODES.map(n => ({
    code: n.code,
    title: n.title,
    credits: n.credits ?? 0,
    core: !!n.core,
    status: (n.status || 'LOCKED').toUpperCase(),
    col: Number(n.col ?? 1),
    row: Number(n.row ?? 0),
    unmet: Array.isArray(n.unmet) ? n.unmet : []
  }));

  const edges = SERVER_EDGES.map(e => ({
    from: e.requiresCode,
    to:   e.courseCode,
    met:  !!e.met
  })).filter(e => e.from && e.to);

  // ----- create DOM cards for nodes -----------------------------------------
  const cardByCode = new Map();

  function statusClass(s){
    if (s === 'COMPLETED') return 'completed';
    if (s === 'ELIGIBLE')  return 'eligible';
    return 'locked';
  }

  function createCard(n){
    const div = document.createElement('div');
    div.className = `node ${statusClass(n.status)}`;
    div.dataset.code = n.code;
    div.dataset.status = statusClass(n.status);
    div.style.left = (40 + (n.col-1)*300) + 'px';
    div.style.top  = (40 + n.row*140) + 'px';

    const h3 = document.createElement('h3');
    h3.textContent = n.code;
    const p = document.createElement('p');
    p.textContent = n.title;
    const meta = document.createElement('div');
    meta.className = 'meta';
    meta.textContent = `${n.credits} cr â€¢ ${n.core ? 'Core' : 'Elective'}`;

    if (n.unmet && n.unmet.length){
      div.title = `Missing: ${n.unmet.join(', ')}`;
    }

    div.append(h3, p, meta);
    board.appendChild(div);
    cardByCode.set(n.code, div);
    makeDraggable(div);
    return div;
  }

  nodes.forEach(createCard);

  // ----- SVG edges layer (persistent <defs>) ---------------------------------
  const NS = 'http://www.w3.org/2000/svg';
  const defs = document.createElementNS(NS, 'defs');
  defs.innerHTML = `
    <marker id="arrow-ok" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <path d="M 0 0 L 10 5 L 0 10 z" fill="#2e7d32"></path>
    </marker>
    <marker id="arrow-eligible" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <path d="M 0 0 L 10 5 L 0 10 z" fill="#1565c0"></path>
    </marker>
    <marker id="arrow-locked" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
      <path d="M 0 0 L 10 5 L 0 10 z" fill="#e57373"></path>
    </marker>`;
  svg.appendChild(defs);

  const edgesG = document.createElementNS(NS,'g');
  edgesG.setAttribute('id','edges-layer');
  svg.appendChild(edgesG);

  function boardRect(){ return board.getBoundingClientRect(); }
  function cardRect(el){
    const r = el.getBoundingClientRect(), b = boardRect();
    return { x:r.left-b.left, y:r.top-b.top, w:r.width, h:r.height };
  }
  function anchorRight(el){ const r = cardRect(el); return { x:r.x + r.w, y:r.y + r.h/2 }; }
  function anchorLeft (el){ const r = cardRect(el); return { x:r.x,       y:r.y + r.h/2 }; }

  function edgeStyle(targetEl){
    const st = targetEl?.dataset.status || 'locked';
    if (st === 'completed') return { cls:'edge ok', marker:'url(#arrow-ok)' };
    if (st === 'eligible')  return { cls:'edge eligible', marker:'url(#arrow-eligible)' };
    return { cls:'edge locked', marker:'url(#arrow-locked)' };
  }

  // rAF-throttled redraw
  let needsDraw = false;
  function scheduleDraw(){
    if (needsDraw) return;
    needsDraw = true;
    requestAnimationFrame(() => { needsDraw = false; drawEdges(); });
  }

  function resizeCanvas(){
    const r = boardRect();
    svg.setAttribute('width', r.width);
    svg.setAttribute('height', r.height);
    svg.setAttribute('viewBox', `0 0 ${r.width} ${r.height}`);
  }

  function drawEdges(){
    resizeCanvas();
    while (edgesG.firstChild) edgesG.removeChild(edgesG.firstChild);

    for (const e of edges){
      const fromEl = cardByCode.get(e.from);
      const toEl   = cardByCode.get(e.to);
      if (!fromEl || !toEl) continue;

      const a = anchorRight(fromEl);
      const b = anchorLeft(toEl);
      const midX = (a.x + b.x) / 2;
      const d = `M ${a.x} ${a.y} C ${midX} ${a.y}, ${midX} ${b.y}, ${b.x} ${b.y}`;

      const st = edgeStyle(toEl);
      const path = document.createElementNS(NS,'path');
      path.setAttribute('d', d);
      path.setAttribute('class', st.cls + (e.met ? '' : ' locked'));
      path.setAttribute('marker-end', st.marker);
      edgesG.appendChild(path);
    }
  }

  // ----- dragging -------------------------------------------------------------
  function makeDraggable(el){
    let start, origin;
    function onMove(e){
      el.style.left = (origin.x + (e.clientX - start.x)) + 'px';
      el.style.top  = (origin.y + (e.clientY - start.y)) + 'px';
      scheduleDraw();
    }
    function onUp(){
      // snap-to-grid (optional)
      const g = 20;
      const x = Math.round(parseInt(el.style.left || '0',10)/g)*g;
      const y = Math.round(parseInt(el.style.top  || '0',10)/g)*g;
      el.style.left = x + 'px'; el.style.top = y + 'px';
      window.removeEventListener('mousemove', onMove);
      scheduleDraw();
    }
    el.addEventListener('mousedown', e => {
      const r = el.getBoundingClientRect(), b = boardRect();
      start  = { x:e.clientX, y:e.clientY };
      origin = { x:r.left - b.left, y:r.top - b.top };
      el.style.position = 'absolute';
      el.style.left = origin.x + 'px';
      el.style.top  = origin.y + 'px';
      el.style.zIndex = 2;
      window.addEventListener('mousemove', onMove);
      window.addEventListener('mouseup', onUp, { once:true });
      e.preventDefault();
    });
  }

  // ----- fit to content -------------------------------------------------------
  function fit(){
    // simple center: ensure all cards are in viewBox (padding applied)
    resizeCanvas(); scheduleDraw();
  }
  document.getElementById('fit').addEventListener('click', fit);

  window.addEventListener('resize', scheduleDraw);
  new ResizeObserver(scheduleDraw).observe(board);

  // initial draw
  setTimeout(scheduleDraw, 80);
})();
</script>
</body>
</html>
